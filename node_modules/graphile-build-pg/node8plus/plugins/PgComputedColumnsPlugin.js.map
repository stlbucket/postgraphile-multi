{"version":3,"sources":["../../src/plugins/PgComputedColumnsPlugin.js"],"names":["PgComputedColumnsPlugin","builder","pgSimpleCollections","hasConnections","hasSimpleCollections","hook","fields","build","context","scope","isPgRowType","isPgCompoundType","isInputType","pgIntrospection","table","fieldWithHooks","Self","kind","namespace","extend","pgIntrospectionResultsByKind","introspectionResultsByKind","inflection","pgOmit","omit","pgMakeProcField","makeProcField","swallowError","describePgEntity","sqlCommentByAddingTags","tableType","type","Error","procedure","reduce","memo","proc","isStable","namespaceId","name","startsWith","argTypeIds","length","id","argTypes","prev","typeId","idx","argModes","push","typeById","slice","some","class","isSelectable","pseudoColumnName","substr","makeField","forceList","fieldName","computedColumnList","computedColumn","computed","e","returnsSet"],"mappings":"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","file":"PgComputedColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgComputedColumnsPlugin(\n  builder,\n  { pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isInputType,\n        pgIntrospection: table,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n\n    if (\n      isInputType ||\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace\n    ) {\n      return fields;\n    }\n\n    const {\n      extend,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      inflection,\n      pgOmit: omit,\n      pgMakeProcField: makeProcField,\n      swallowError,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const tableType = table.type;\n    if (!tableType) {\n      throw new Error(\"Could not determine the type for this table\");\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.procedure.reduce((memo, proc) => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.isStable) return memo;\n        if (proc.namespaceId !== table.namespaceId) return memo;\n        if (!proc.name.startsWith(`${table.name}_`)) return memo;\n        if (proc.argTypeIds.length < 1) return memo;\n        if (proc.argTypeIds[0] !== tableType.id) return memo;\n        if (omit(proc, \"execute\")) return memo;\n\n        const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n          if (\n            proc.argModes.length === 0 || // all args are `in`\n            proc.argModes[idx] === \"i\" || // this arg is `in`\n            proc.argModes[idx] === \"b\" // this arg is `inout`\n          ) {\n            prev.push(introspectionResultsByKind.typeById[typeId]);\n          }\n          return prev;\n        }, []);\n        if (\n          argTypes\n            .slice(1)\n            .some(\n              type => type.type === \"c\" && type.class && type.class.isSelectable\n            )\n        ) {\n          // Accepts two input tables? Skip.\n          return memo;\n        }\n\n        const pseudoColumnName = proc.name.substr(table.name.length + 1);\n        function makeField(forceList) {\n          const fieldName = forceList\n            ? inflection.computedColumnList(pseudoColumnName, proc, table)\n            : inflection.computedColumn(pseudoColumnName, proc, table);\n          try {\n            memo = extend(\n              memo,\n              {\n                [fieldName]: makeProcField(fieldName, proc, build, {\n                  fieldWithHooks,\n                  computed: true,\n                  forceList,\n                }),\n              },\n              `Adding computed column for ${describePgEntity(\n                proc\n              )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n                proc,\n                {\n                  fieldName: \"newNameHere\",\n                }\n              )}`\n            );\n          } catch (e) {\n            swallowError(e);\n          }\n        }\n        if (!proc.returnsSet || hasConnections) {\n          makeField(false);\n        }\n        if (proc.returnsSet && hasSimpleCollections) {\n          makeField(true);\n        }\n        return memo;\n      }, {}),\n      `Adding computed column to '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}