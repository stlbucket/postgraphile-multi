{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","base64Decode","str","Buffer","from","String","toString","PgMutationUpdateDeletePlugin","builder","pgDisableDefaultMutations","hook","fields","build","context","newWithHooks","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getNodeType","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","pgField","scope","isRootMutation","fieldWithHooks","pluralize","singularize","camelCase","reduce","outerMemo","mode","class","memo","table","namespace","canUpdate","isUpdatable","canDelete","isDeletable","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","input","condition","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableFieldName","attributes","forEach","attr","fieldName","column","val","push","typeModifier","length","query","join","map","col","i","fragment","modifiedRowAlias","Symbol","row","rows","e","Error","clientMutationId","data","uniqueConstraints","constraints","filter","con","Table","tableTypeName","TablePatch","patchType","description","tableName","deletedNodeIdFieldName","Object","assign","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","resolve","__identifiers","isPgMutationPayloadDeletedNodeIdField","__origin","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributes","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","pgInflection","isMutationInput","args","parent","nodeId","alias","identifiers","JSON","parse","NodeTypeByAlias","key","idx","isPgNodeMutation","pgFieldIntrospection","constraint","keys","every","_","some","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys"],"mappings":"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","file":"PgMutationUpdateDeletePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\nconst base64Decode = str => Buffer.from(String(str), \"base64\").toString(\"utf8\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      newWithHooks,\n      getNodeIdForTypeAndIdentifiers,\n      nodeIdFieldName,\n      fieldDataGeneratorsByType,\n      extend,\n      parseResolveInfo,\n      getTypeByName,\n      gql2pg,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      getNodeType,\n      graphql: {\n        GraphQLNonNull,\n        GraphQLInputObjectType,\n        GraphQLString,\n        GraphQLObjectType,\n        GraphQLID,\n      },\n      pgColumnFilter,\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n      pgViaTemporaryTable: viaTemporaryTable,\n      describePgEntity,\n      sqlCommentByAddingTags,\n      pgField,\n    } = build;\n    const {\n      scope: { isRootMutation },\n      fieldWithHooks,\n    } = context;\n\n    const { pluralize, singularize, camelCase } = inflection;\n\n    if (!isRootMutation) {\n      return fields;\n    }\n\n    return extend(\n      fields,\n      [\"update\", \"delete\"].reduce(\n        (outerMemo, mode) =>\n          introspectionResultsByKind.class.reduce((memo, table) => {\n            // PERFORMANCE: These used to be .filter(...) calls\n            if (!table.namespace) return memo;\n            const canUpdate =\n              mode === \"update\" && table.isUpdatable && !omit(table, \"update\");\n            const canDelete =\n              mode === \"delete\" && table.isDeletable && !omit(table, \"delete\");\n            if (!canUpdate && !canDelete) return memo;\n\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              table.type.id,\n              null\n            );\n            if (!TableType) {\n              return memo;\n            }\n            async function commonCodeRenameMe(\n              pgClient,\n              resolveInfo,\n              getDataFromParsedResolveInfoFragment,\n              PayloadType,\n              input,\n              condition,\n              context\n            ) {\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              const resolveData = getDataFromParsedResolveInfoFragment(\n                parsedResolveInfoFragment,\n                PayloadType\n              );\n\n              const sqlTypeIdentifier = sql.identifier(\n                table.namespace.name,\n                table.name\n              );\n\n              let sqlMutationQuery;\n              if (mode === \"update\") {\n                const sqlColumns = [];\n                const sqlValues = [];\n                const inputData =\n                  input[\n                    inflection.patchField(inflection.tableFieldName(table))\n                  ];\n                table.attributes.forEach(attr => {\n                  // PERFORMANCE: These used to be .filter(...) calls\n                  if (!pgColumnFilter(attr, build, context)) return;\n                  if (omit(attr, \"update\")) return;\n\n                  const fieldName = inflection.column(attr);\n                  if (\n                    fieldName in inputData /* Because we care about null! */\n                  ) {\n                    const val = inputData[fieldName];\n                    sqlColumns.push(sql.identifier(attr.name));\n                    sqlValues.push(gql2pg(val, attr.type, attr.typeModifier));\n                  }\n                });\n                if (sqlColumns.length === 0) {\n                  return null;\n                }\n                sqlMutationQuery = sql.query`\n                update ${sql.identifier(\n                  table.namespace.name,\n                  table.name\n                )} set ${sql.join(\n                  sqlColumns.map(\n                    (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                  ),\n                  \", \"\n                )}\n                where ${condition}\n                returning *`;\n              } else {\n                sqlMutationQuery = sql.query`\n                delete from ${sql.identifier(table.namespace.name, table.name)}\n                where ${condition}\n                returning *`;\n              }\n\n              const modifiedRowAlias = sql.identifier(Symbol());\n              const query = queryFromResolveData(\n                modifiedRowAlias,\n                modifiedRowAlias,\n                resolveData,\n                {}\n              );\n              let row;\n              try {\n                await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                const rows = await viaTemporaryTable(\n                  pgClient,\n                  sqlTypeIdentifier,\n                  sqlMutationQuery,\n                  modifiedRowAlias,\n                  query\n                );\n                row = rows[0];\n                await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n              } catch (e) {\n                await pgClient.query(\"ROLLBACK TO SAVEPOINT graphql_mutation\");\n                throw e;\n              }\n              if (!row) {\n                throw new Error(\n                  `No values were ${mode}d in collection '${pluralize(\n                    table.name\n                  )}' because no values were found.`\n                );\n              }\n              return {\n                clientMutationId: input.clientMutationId,\n                data: row,\n              };\n            }\n            if (TableType) {\n              const uniqueConstraints = table.constraints.filter(\n                con => con.type === \"u\" || con.type === \"p\"\n              );\n              const Table = pgGetGqlTypeByTypeIdAndModifier(\n                table.type.id,\n                null\n              );\n              const tableTypeName = Table.name;\n              const TablePatch = getTypeByName(\n                inflection.patchType(Table.name)\n              );\n              const PayloadType = newWithHooks(\n                GraphQLObjectType,\n                {\n                  name: inflection[\n                    mode === \"delete\"\n                      ? \"deletePayloadType\"\n                      : \"updatePayloadType\"\n                  ](table),\n                  description: `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                  fields: ({ fieldWithHooks }) => {\n                    const tableName = inflection.tableFieldName(table);\n                    // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                    const deletedNodeIdFieldName = camelCase(\n                      `deleted-${singularize(table.name)}-id`\n                    );\n                    return Object.assign(\n                      {\n                        clientMutationId: {\n                          description:\n                            \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                          type: GraphQLString,\n                        },\n                        [tableName]: pgField(\n                          build,\n                          fieldWithHooks,\n                          tableName,\n                          {\n                            description: `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                            type: Table,\n                          },\n                          {},\n                          false\n                        ),\n                      },\n                      mode === \"delete\"\n                        ? {\n                            [deletedNodeIdFieldName]: fieldWithHooks(\n                              deletedNodeIdFieldName,\n                              ({ addDataGenerator }) => {\n                                const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                  TableType\n                                );\n\n                                const gens =\n                                  fieldDataGeneratorsByTableType &&\n                                  fieldDataGeneratorsByTableType[\n                                    nodeIdFieldName\n                                  ];\n                                if (gens) {\n                                  gens.forEach(gen => addDataGenerator(gen));\n                                }\n                                return {\n                                  type: GraphQLID,\n                                  resolve(data) {\n                                    return (\n                                      data.data.__identifiers &&\n                                      getNodeIdForTypeAndIdentifiers(\n                                        Table,\n                                        ...data.data.__identifiers\n                                      )\n                                    );\n                                  },\n                                };\n                              },\n                              {\n                                isPgMutationPayloadDeletedNodeIdField: true,\n                              }\n                            ),\n                          }\n                        : null\n                    );\n                  },\n                },\n                {\n                  __origin: `Adding table ${mode} mutation payload type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  isMutationPayload: true,\n                  isPgUpdatePayloadType: mode === \"update\",\n                  isPgDeletePayloadType: mode === \"delete\",\n                  pgIntrospection: table,\n                }\n              );\n\n              // NodeId\n              const primaryKeyConstraint = table.primaryKeyConstraint;\n              if (nodeIdFieldName && primaryKeyConstraint) {\n                const primaryKeys =\n                  primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n                const fieldName = inflection[\n                  mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                ](table);\n                const InputType = newWithHooks(\n                  GraphQLInputObjectType,\n                  {\n                    description: `All input for the \\`${fieldName}\\` mutation.`,\n                    name: inflection[\n                      mode === \"update\"\n                        ? \"updateNodeInputType\"\n                        : \"deleteNodeInputType\"\n                    ](table),\n                    fields: Object.assign(\n                      {\n                        clientMutationId: {\n                          description:\n                            \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                          type: GraphQLString,\n                        },\n                        [nodeIdFieldName]: {\n                          description: `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                          type: new GraphQLNonNull(GraphQLID),\n                        },\n                      },\n                      mode === \"update\"\n                        ? {\n                            [inflection.patchField(\n                              inflection.tableFieldName(table)\n                            )]: {\n                              description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                              type: new GraphQLNonNull(TablePatch),\n                            },\n                          }\n                        : null\n                    ),\n                  },\n                  {\n                    __origin: `Adding table ${mode} (by node ID) mutation input type for ${describePgEntity(\n                      table\n                    )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isPgUpdateInputType: mode === \"update\",\n                    isPgUpdateNodeInputType: mode === \"update\",\n                    isPgDeleteInputType: mode === \"delete\",\n                    isPgDeleteNodeInputType: mode === \"delete\",\n                    pgInflection: table,\n                    isMutationInput: true,\n                  }\n                );\n\n                memo = extend(\n                  memo,\n                  {\n                    [fieldName]: fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            const nodeId = input[nodeIdFieldName];\n                            try {\n                              const [alias, ...identifiers] = JSON.parse(\n                                base64Decode(nodeId)\n                              );\n                              const NodeTypeByAlias = getNodeType(alias);\n                              if (NodeTypeByAlias !== TableType) {\n                                throw new Error(\"Mismatched type\");\n                              }\n                              if (identifiers.length !== primaryKeys.length) {\n                                throw new Error(\"Invalid ID\");\n                              }\n\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                input,\n                                sql.fragment`(${sql.join(\n                                  primaryKeys.map(\n                                    (key, idx) =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        identifiers[idx],\n                                        key.type,\n                                        key.typeModifier\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context\n                              );\n                            } catch (e) {\n                              debug(e);\n                              return null;\n                            }\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: true,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    ),\n                  },\n                  \"Adding ${mode} mutation for ${describePgEntity(table)}\"\n                );\n              }\n\n              // Unique\n              uniqueConstraints.forEach(constraint => {\n                if (omit(constraint, mode)) {\n                  return;\n                }\n                const keys = constraint.keyAttributes;\n                if (!keys.every(_ => _)) {\n                  throw new Error(\n                    `Consistency error: could not find an attribute in the constraint when building the ${mode} mutation for ${describePgEntity(\n                      table\n                    )}!`\n                  );\n                }\n                if (keys.some(key => omit(key, \"read\"))) {\n                  return;\n                }\n                const fieldName = inflection[\n                  mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                ](keys, table, constraint);\n                const InputType = newWithHooks(\n                  GraphQLInputObjectType,\n                  {\n                    description: `All input for the \\`${fieldName}\\` mutation.`,\n                    name: inflection[\n                      mode === \"update\"\n                        ? \"updateByKeysInputType\"\n                        : \"deleteByKeysInputType\"\n                    ](keys, table, constraint),\n                    fields: Object.assign(\n                      {\n                        clientMutationId: {\n                          type: GraphQLString,\n                        },\n                      },\n                      mode === \"update\"\n                        ? {\n                            [inflection.patchField(\n                              inflection.tableFieldName(table)\n                            )]: {\n                              description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                              type: new GraphQLNonNull(TablePatch),\n                            },\n                          }\n                        : null,\n                      keys.reduce((memo, key) => {\n                        memo[inflection.column(key)] = {\n                          description: key.description,\n                          type: new GraphQLNonNull(\n                            pgGetGqlInputTypeByTypeIdAndModifier(\n                              key.typeId,\n                              key.typeModifier\n                            )\n                          ),\n                        };\n                        return memo;\n                      }, {})\n                    ),\n                  },\n                  {\n                    __origin: `Adding table ${mode} mutation input type for ${describePgEntity(\n                      constraint\n                    )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isPgUpdateInputType: mode === \"update\",\n                    isPgUpdateByKeysInputType: mode === \"update\",\n                    isPgDeleteInputType: mode === \"delete\",\n                    isPgDeleteByKeysInputType: mode === \"delete\",\n                    pgInflection: table,\n                    pgKeys: keys,\n                    isMutationInput: true,\n                  }\n                );\n\n                memo = extend(\n                  memo,\n                  {\n                    [fieldName]: fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            return commonCodeRenameMe(\n                              pgClient,\n                              resolveInfo,\n                              getDataFromParsedResolveInfoFragment,\n                              PayloadType,\n                              input,\n                              sql.fragment`(${sql.join(\n                                keys.map(\n                                  key =>\n                                    sql.fragment`${sql.identifier(\n                                      key.name\n                                    )} = ${gql2pg(\n                                      input[inflection.column(key)],\n                                      key.type,\n                                      key.typeModifier\n                                    )}`\n                                ),\n                                \") and (\"\n                              )})`,\n                              context\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: false,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    ),\n                  },\n                  `Adding ${mode} mutation for ${describePgEntity(constraint)}`\n                );\n              });\n            }\n            return memo;\n          }, outerMemo),\n        {}\n      ),\n      `Adding default update/delete mutations to root Mutation type`\n    );\n  });\n}: Plugin);\n"]}