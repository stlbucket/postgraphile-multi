{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","hasOwnProperty","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","handleNullRow","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","select","fragment","join","map","key","getTableAlias","identifier","resolve","data","__origin","pgIntrospection","isPgRowType","isPgCompoundType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","namespaceName","null","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","_context","resolveInfo","safeAlias","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","file":"PgTablesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (row.hasOwnProperty(k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? row => row\n    : row => {\n        if (hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\"init\", (_, build) => {\n    const {\n      getNodeIdForTypeAndIdentifiers,\n      nodeIdFieldName,\n      newWithHooks,\n      getSafeAliasFromResolveInfo,\n      pgSql: sql,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgRegisterGqlTypeByTypeId,\n      pgRegisterGqlInputTypeByTypeId,\n      pg2GqlMapper,\n      gql2pg,\n      graphql: {\n        GraphQLObjectType,\n        GraphQLNonNull,\n        GraphQLID,\n        GraphQLList,\n        GraphQLInputObjectType,\n      },\n      inflection,\n      describePgEntity,\n      sqlCommentByAddingTags,\n      pgField,\n    } = build;\n\n    const nullableIf = (condition, Type) =>\n      condition ? Type : new GraphQLNonNull(Type);\n    const Cursor = getTypeByName(\"Cursor\");\n\n    introspectionResultsByKind.class.forEach(table => {\n      const tablePgType = table.type;\n      if (!tablePgType) {\n        throw new Error(\"Could not determine the type for this table\");\n      }\n      const arrayTablePgType = tablePgType.arrayType;\n      const primaryKeyConstraint = table.primaryKeyConstraint;\n      const primaryKeys =\n        primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n      const attributes = table.attributes;\n      const tableTypeName = inflection.tableType(table);\n      const shouldHaveNodeId: boolean =\n        nodeIdFieldName &&\n        table.isSelectable &&\n        table.namespace &&\n        primaryKeys &&\n        primaryKeys.length\n          ? true\n          : false;\n      let TableType;\n      let TablePatchType;\n      let TableBaseInputType;\n      pgRegisterGqlTypeByTypeId(\n        tablePgType.id,\n        cb => {\n          if (TableType) {\n            return TableType;\n          }\n          if (pg2GqlMapper[tablePgType.id]) {\n            // Already handled\n            throw new Error(\n              `Register was called but there's already a mapper in place for '${\n                tablePgType.id\n              }'!`\n            );\n          }\n          TableType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: table.description || tablePgType.description,\n              name: tableTypeName,\n              interfaces: () => {\n                if (shouldHaveNodeId) {\n                  return [getTypeByName(\"Node\")];\n                } else {\n                  return [];\n                }\n              },\n              fields: ({ addDataGeneratorForField, Self }) => {\n                const fields = {};\n                if (shouldHaveNodeId) {\n                  // Enable nodeId interface\n                  addDataGeneratorForField(nodeIdFieldName, () => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          sql.fragment`json_build_array(${sql.join(\n                            primaryKeys.map(\n                              key =>\n                                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )}`\n                            ),\n                            \", \"\n                          )})`,\n                          \"__identifiers\"\n                        );\n                      },\n                    };\n                  });\n                  fields[nodeIdFieldName] = {\n                    description:\n                      \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                    type: new GraphQLNonNull(GraphQLID),\n                    resolve(data) {\n                      return (\n                        data.__identifiers &&\n                        getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...data.__identifiers\n                        )\n                      );\n                    },\n                  };\n                }\n                return fields;\n              },\n            },\n            {\n              __origin: `Adding table type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              pgIntrospection: table,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n            }\n          );\n          cb(TableType);\n          const pgCreateInputFields = {};\n          const pgPatchInputFields = {};\n          const pgBaseInputFields = {};\n          newWithHooks(\n            GraphQLInputObjectType,\n            {\n              description: `An input for mutations affecting \\`${tableTypeName}\\``,\n              name: inflection.inputType(TableType),\n            },\n            {\n              __origin: `Adding table input type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              pgIntrospection: table,\n              isInputType: true,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n              pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                pgCreateInputFields[fieldName] = {\n                  name: attrName,\n                  type: pgType,\n                  typeModifier,\n                };\n                return spec;\n              },\n            },\n            true // If no fields, skip type automatically\n          );\n\n          if (table.isSelectable) {\n            // XXX: these don't belong here; but we have to keep them here\n            // because third-party code depends on `getTypeByName` to find\n            // them; so we have to register them ahead of time. A better\n            // approach is to use the modifier to specify the type you need,\n            // 'patch' or 'base', so they can be registered just in time.\n            TablePatchType = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                name: inflection.patchType(TableType),\n              },\n              {\n                __origin: `Adding table patch type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                isPgPatch: true,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgPatchInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // Safe to skip this if no fields support updating\n            );\n            TableBaseInputType = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                name: inflection.baseInputType(TableType),\n              },\n              {\n                __origin: `Adding table base input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                isPgBaseInput: true,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgBaseInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              }\n            );\n          }\n\n          pg2GqlMapper[tablePgType.id] = {\n            map: _ => _,\n            unmap: (obj, modifier) => {\n              let fieldLookup;\n              if (modifier === \"patch\") {\n                fieldLookup = pgPatchInputFields;\n              } else if (modifier === \"base\") {\n                fieldLookup = pgBaseInputFields;\n              } else {\n                fieldLookup = pgCreateInputFields;\n              }\n\n              const attr2sql = attr => {\n                // TODO: this should use `fieldInput[*].name` to find the attribute\n                const fieldName = inflection.column(attr);\n                const inputField = fieldLookup[fieldName];\n                const v = obj[fieldName];\n                if (inputField && v != null) {\n                  const { type, typeModifier } = inputField;\n                  return sql.fragment`${gql2pg(\n                    v,\n                    type,\n                    typeModifier\n                  )}::${sql.identifier(type.namespaceName, type.name)}`;\n                } else {\n                  return sql.null; // TODO: return default instead.\n                }\n              };\n\n              return sql.fragment`row(${sql.join(\n                attributes.map(attr2sql),\n                \",\"\n              )})::${sql.identifier(\n                tablePgType.namespaceName,\n                tablePgType.name\n              )}`;\n            },\n          };\n\n          const EdgeType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A \\`${tableTypeName}\\` edge in the connection.`,\n              name: inflection.edge(TableType.name),\n              fields: ({ fieldWithHooks }) => {\n                return {\n                  cursor: fieldWithHooks(\n                    \"cursor\",\n                    ({ addDataGenerator }) => {\n                      addDataGenerator(() => ({\n                        usesCursor: [true],\n                        pgQuery: queryBuilder => {\n                          if (primaryKeys) {\n                            queryBuilder.select(\n                              sql.fragment`json_build_array(${sql.join(\n                                primaryKeys.map(\n                                  key =>\n                                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                      key.name\n                                    )}`\n                                ),\n                                \", \"\n                              )})`,\n                              \"__identifiers\"\n                            );\n                          }\n                        },\n                      }));\n                      return {\n                        description: \"A cursor for use in pagination.\",\n                        type: Cursor,\n                        resolve(data) {\n                          return (\n                            data.__cursor &&\n                            base64(JSON.stringify(data.__cursor))\n                          );\n                        },\n                      };\n                    },\n                    {\n                      isCursorField: true,\n                    }\n                  ),\n                  node: pgField(\n                    build,\n                    fieldWithHooks,\n                    \"node\",\n                    {\n                      description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                      type: nullableIf(\n                        !pgForbidSetofFunctionsToReturnNull,\n                        TableType\n                      ),\n                      resolve(data, _args, _context, resolveInfo) {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        return handleNullRow(data[safeAlias]);\n                      },\n                    },\n                    {},\n                    false\n                  ),\n                };\n              },\n            },\n            {\n              __origin: `Adding table edge type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              isEdgeType: true,\n              isPgRowEdgeType: true,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n          const PageInfo = getTypeByName(\"PageInfo\");\n\n          /*const ConnectionType = */\n          newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n              name: inflection.connection(TableType.name),\n              fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                recurseDataGeneratorsForField(\"pageInfo\", true);\n                return {\n                  nodes: pgField(\n                    build,\n                    fieldWithHooks,\n                    \"nodes\",\n                    {\n                      description: `A list of \\`${tableTypeName}\\` objects.`,\n                      type: new GraphQLNonNull(\n                        new GraphQLList(\n                          nullableIf(\n                            !pgForbidSetofFunctionsToReturnNull,\n                            TableType\n                          )\n                        )\n                      ),\n                      resolve(data, _args, _context, resolveInfo) {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        return data.data.map(entry =>\n                          handleNullRow(entry[safeAlias])\n                        );\n                      },\n                    },\n                    {},\n                    false\n                  ),\n                  edges: pgField(\n                    build,\n                    fieldWithHooks,\n                    \"edges\",\n                    {\n                      description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                      type: new GraphQLNonNull(\n                        new GraphQLList(new GraphQLNonNull(EdgeType))\n                      ),\n                      resolve(data, _args, _context, resolveInfo) {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        return data.data.map(entry => ({\n                          __cursor: entry.__cursor,\n                          ...entry[safeAlias],\n                        }));\n                      },\n                    },\n                    {},\n                    false,\n                    {\n                      hoistCursor: true,\n                    }\n                  ),\n                  pageInfo: PageInfo && {\n                    description: \"Information to aid in pagination.\",\n                    type: new GraphQLNonNull(PageInfo),\n                    resolve(data) {\n                      return data;\n                    },\n                  },\n                };\n              },\n            },\n            {\n              __origin: `Adding table connection type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              isConnectionType: true,\n              isPgRowConnectionType: true,\n              edgeType: EdgeType,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n        },\n        true\n      );\n      pgRegisterGqlInputTypeByTypeId(\n        tablePgType.id,\n        (_set, modifier) => {\n          // This must come first, it triggers creation of all the types\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            tablePgType.id,\n            null\n          );\n          // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n          if (modifier === \"patch\") {\n            // TODO: v5: move the definition from above down here\n            return TablePatchType;\n          }\n          if (modifier === \"base\") {\n            // TODO: v5: move the definition from above down here\n            return TableBaseInputType;\n          }\n          if (TableType) {\n            return getTypeByName(inflection.inputType(TableType));\n          }\n          return null;\n        },\n        true\n      );\n\n      if (arrayTablePgType) {\n        // Note: these do not return\n        //\n        // `new GraphQLList(new GraphQLNonNull(...))`\n        //\n        // because it's possible to return null entries from postgresql\n        // functions. We should probably add a flag to instead export\n        // the non-null version as that's more typical.\n        pgRegisterGqlTypeByTypeId(\n          arrayTablePgType.id,\n          () => {\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            return new GraphQLList(TableType);\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          arrayTablePgType.id,\n          (_set, modifier) => {\n            const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n              tablePgType.id,\n              modifier\n            );\n            if (RelevantTableInputType) {\n              return new GraphQLList(RelevantTableInputType);\n            }\n          },\n          true\n        );\n      }\n    });\n    return _;\n  });\n}: Plugin);\n"]}