"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _withPgClient = require("../withPgClient");

var _withPgClient2 = _interopRequireDefault(_withPgClient);

var _utils = require("../utils");

var _fs = require("fs");

var _pg = require("pg");

var _pg2 = _interopRequireDefault(_pg);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _chalk = require("chalk");

var _chalk2 = _interopRequireDefault(_chalk);

var _throttle = require("lodash/throttle");

var _throttle2 = _interopRequireDefault(_throttle);

var _flatMap = require("lodash/flatMap");

var _flatMap2 = _interopRequireDefault(_flatMap);

var _introspectionQuery = require("./introspectionQuery");

var _package = require("../../package.json");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("graphile-build-pg");
const WATCH_FIXTURES_PATH = `${__dirname}/../../res/watch-fixtures.sql`;

// Ref: https://github.com/graphile/postgraphile/tree/master/src/postgres/introspection/object

function readFile(filename, encoding) {
  return new Promise((resolve, reject) => {
    (0, _fs.readFile)(filename, encoding, (err, res) => {
      if (err) reject(err);else resolve(res);
    });
  });
}

exports.default = async function PgIntrospectionPlugin(builder, {
  pgConfig,
  pgSchemas: schemas,
  pgEnableTags,
  persistentMemoizeWithKey = (key, fn) => fn(),
  pgThrowOnMissingSchema = false,
  pgIncludeExtensionResources = false,
  pgLegacyFunctionsOnly = false,
  pgSkipInstallingWatchFixtures = false
}) {
  async function introspect() {
    // Perform introspection
    if (!Array.isArray(schemas)) {
      throw new Error("Argument 'schemas' (array) is required");
    }
    const cacheKey = `PgIntrospectionPlugin-introspectionResultsByKind-v${_package.version}`;
    const cloneResults = obj => {
      const result = Object.keys(obj).reduce((memo, k) => {
        memo[k] = obj[k].map(v => Object.assign({}, v));
        return memo;
      }, {});
      return result;
    };
    const introspectionResultsByKind = cloneResults((await persistentMemoizeWithKey(cacheKey, () => (0, _withPgClient2.default)(pgConfig, async pgClient => {
      const versionResult = await pgClient.query("show server_version_num;");
      const serverVersionNum = parseInt(versionResult.rows[0].server_version_num, 10);
      const introspectionQuery = (0, _introspectionQuery.makeIntrospectionQuery)(serverVersionNum, {
        pgLegacyFunctionsOnly
      });
      const { rows } = await pgClient.query(introspectionQuery, [schemas, pgIncludeExtensionResources]);

      const result = {
        namespace: [],
        class: [],
        attribute: [],
        type: [],
        constraint: [],
        procedure: [],
        extension: [],
        index: []
      };
      for (const { object } of rows) {
        result[object.kind].push(object);
      }

      // Parse tags from comments
      ["namespace", "class", "attribute", "type", "constraint", "procedure", "extension", "index"].forEach(kind => {
        result[kind].forEach(object => {
          // Keep a copy of the raw comment
          object.comment = object.description;
          if (pgEnableTags && object.description) {
            const parsed = (0, _utils.parseTags)(object.description);
            object.tags = parsed.tags;
            object.description = parsed.text;
          } else {
            object.tags = {};
          }
        });
      });

      const extensionConfigurationClassIds = (0, _flatMap2.default)(result.extension, e => e.configurationClassIds);
      result.class.forEach(klass => {
        klass.isExtensionConfigurationTable = extensionConfigurationClassIds.indexOf(klass.id) >= 0;
      });

      for (const k in result) {
        result[k].forEach(Object.freeze);
      }
      return Object.freeze(result);
    }))));

    const knownSchemas = introspectionResultsByKind.namespace.map(n => n.name);
    const missingSchemas = schemas.filter(s => knownSchemas.indexOf(s) < 0);
    if (missingSchemas.length) {
      const errorMessage = `You requested to use schema '${schemas.join("', '")}'; however we couldn't find some of those! Missing schemas are: '${missingSchemas.join("', '")}'`;
      if (pgThrowOnMissingSchema) {
        throw new Error(errorMessage);
      } else {
        console.warn("⚠️ WARNING⚠️  " + errorMessage); // eslint-disable-line no-console
      }
    }

    const xByY = (arrayOfX, attrKey) => arrayOfX.reduce((memo, x) => {
      memo[x[attrKey]] = x;
      return memo;
    }, {});
    const xByYAndZ = (arrayOfX, attrKey, attrKey2) => arrayOfX.reduce((memo, x) => {
      if (!memo[x[attrKey]]) memo[x[attrKey]] = {};
      memo[x[attrKey]][x[attrKey2]] = x;
      return memo;
    }, {});
    introspectionResultsByKind.namespaceById = xByY(introspectionResultsByKind.namespace, "id");
    introspectionResultsByKind.classById = xByY(introspectionResultsByKind.class, "id");
    introspectionResultsByKind.typeById = xByY(introspectionResultsByKind.type, "id");
    introspectionResultsByKind.attributeByClassIdAndNum = xByYAndZ(introspectionResultsByKind.attribute, "classId", "num");
    introspectionResultsByKind.extensionById = xByY(introspectionResultsByKind.extension, "id");

    const relate = (array, newAttr, lookupAttr, lookup, missingOk = false) => {
      array.forEach(entry => {
        const key = entry[lookupAttr];
        if (Array.isArray(key)) {
          entry[newAttr] = key.map(innerKey => {
            const result = lookup[innerKey];
            if (innerKey && !result) {
              if (missingOk) {
                return;
              }
              throw new Error(`Could not look up '${newAttr}' by '${lookupAttr}' ('${innerKey}') on '${JSON.stringify(entry)}'`);
            }
            return result;
          }).filter(_ => _);
        } else {
          const result = lookup[key];
          if (key && !result) {
            if (missingOk) {
              return;
            }
            throw new Error(`Could not look up '${newAttr}' by '${lookupAttr}' on '${JSON.stringify(entry)}'`);
          }
          entry[newAttr] = result;
        }
      });
    };

    relate(introspectionResultsByKind.class, "namespace", "namespaceId", introspectionResultsByKind.namespaceById, true // Because it could be a type defined in a different namespace - which is fine so long as we don't allow querying it directly
    );

    relate(introspectionResultsByKind.class, "type", "typeId", introspectionResultsByKind.typeById);

    relate(introspectionResultsByKind.attribute, "class", "classId", introspectionResultsByKind.classById);

    relate(introspectionResultsByKind.attribute, "type", "typeId", introspectionResultsByKind.typeById);

    relate(introspectionResultsByKind.procedure, "namespace", "namespaceId", introspectionResultsByKind.namespaceById);

    relate(introspectionResultsByKind.type, "class", "classId", introspectionResultsByKind.classById, true);

    relate(introspectionResultsByKind.type, "domainBaseType", "domainBaseTypeId", introspectionResultsByKind.typeById, true // Because not all types are domains
    );

    relate(introspectionResultsByKind.type, "arrayItemType", "arrayItemTypeId", introspectionResultsByKind.typeById, true // Because not all types are arrays
    );

    relate(introspectionResultsByKind.constraint, "class", "classId", introspectionResultsByKind.classById);

    relate(introspectionResultsByKind.constraint, "foreignClass", "foreignClassId", introspectionResultsByKind.classById, true // Because many constraints don't apply to foreign classes
    );

    relate(introspectionResultsByKind.extension, "namespace", "namespaceId", introspectionResultsByKind.namespaceById, true // Because the extension could be a defined in a different namespace
    );

    relate(introspectionResultsByKind.extension, "configurationClasses", "configurationClassIds", introspectionResultsByKind.classById, true // Because the configuration table could be a defined in a different namespace
    );

    relate(introspectionResultsByKind.index, "class", "classId", introspectionResultsByKind.classById);

    // Reverse arrayItemType -> arrayType
    introspectionResultsByKind.type.forEach(type => {
      if (type.arrayItemType) {
        type.arrayItemType.arrayType = type;
      }
    });

    // Table/type columns / constraints
    introspectionResultsByKind.class.forEach(klass => {
      klass.attributes = introspectionResultsByKind.attribute.filter(attr => attr.classId === klass.id);
      klass.constraints = introspectionResultsByKind.constraint.filter(constraint => constraint.classId === klass.id);
      klass.foreignConstraints = introspectionResultsByKind.constraint.filter(constraint => constraint.foreignClassId === klass.id);
      klass.primaryKeyConstraint = klass.constraints.find(constraint => constraint.type === "p");
    });

    // Constraint attributes
    introspectionResultsByKind.constraint.forEach(constraint => {
      if (constraint.keyAttributeNums && constraint.class) {
        constraint.keyAttributes = constraint.keyAttributeNums.map(nr => constraint.class.attributes.find(attr => attr.num === nr));
      } else {
        constraint.keyAttributes = [];
      }
      if (constraint.foreignKeyAttributeNums && constraint.foreignClass) {
        constraint.foreignKeyAttributes = constraint.foreignKeyAttributeNums.map(nr => constraint.foreignClass.attributes.find(attr => attr.num === nr));
      } else {
        constraint.foreignKeyAttributes = [];
      }
    });

    // Detect which columns and constraints are indexed
    introspectionResultsByKind.index.forEach(index => {
      const columns = index.attributeNums.map(nr => index.class.attributes.find(attr => attr.num === nr));

      // Indexed column (for orderBy / filter):
      if (columns[0]) {
        columns[0].isIndexed = true;
      }

      // Indexed constraints (for reverse relations):
      index.class.constraints.filter(constraint => constraint.type === "f").forEach(constraint => {
        if (constraint.keyAttributeNums.every((nr, idx) => index.attributeNums[idx] === nr)) {
          constraint.isIndexed = true;
        }
      });
    });

    return introspectionResultsByKind;
  }

  let introspectionResultsByKind = await introspect();

  let pgClient, releasePgClient, listener;

  function stopListening() {
    if (pgClient) {
      pgClient.query("unlisten postgraphile_watch").catch(e => {
        debug(`Error occurred trying to unlisten watch: ${e}`);
      });
      pgClient.removeListener("notification", listener);
    }
    if (releasePgClient) {
      releasePgClient();
      pgClient = null;
    }
  }

  builder.registerWatcher(async triggerRebuild => {
    // In case we started listening before, clean up
    await stopListening();

    // Check we can get a pgClient
    if (pgConfig instanceof _pg2.default.Pool || (0, _withPgClient.quacksLikePgPool)(pgConfig)) {
      pgClient = await pgConfig.connect();
      releasePgClient = () => pgClient && pgClient.release();
    } else if (typeof pgConfig === "string") {
      pgClient = new _pg2.default.Client(pgConfig);
      pgClient.on("error", e => {
        debug("pgClient error occurred: %s", e);
      });
      releasePgClient = () => new Promise((resolve, reject) => {
        if (pgClient) pgClient.end(err => err ? reject(err) : resolve());else resolve();
      });
      await new Promise((resolve, reject) => {
        if (pgClient) {
          pgClient.connect(err => err ? reject(err) : resolve());
        } else {
          resolve();
        }
      });
    } else {
      throw new Error("Cannot watch schema with this configuration - need a string or pg.Pool");
    }
    // Install the watch fixtures.
    if (!pgSkipInstallingWatchFixtures) {
      const watchSqlInner = await readFile(WATCH_FIXTURES_PATH, "utf8");
      const sql = `begin; ${watchSqlInner}; commit;`;
      try {
        await pgClient.query(sql);
      } catch (error) {
        /* eslint-disable no-console */
        console.warn(`${_chalk2.default.bold.yellow("Failed to setup watch fixtures in Postgres database")} ️️⚠️`);
        console.warn(_chalk2.default.yellow("This is likely because your Postgres user is not a superuser. If the"));
        console.warn(_chalk2.default.yellow("fixtures already exist, the watch functionality may still work."));
        console.warn(_chalk2.default.yellow("Enable DEBUG='graphile-build-pg' to see the error"));
        debug(error);
        /* eslint-enable no-console */
        await pgClient.query("rollback");
      }
    }

    await pgClient.query("listen postgraphile_watch");

    const handleChange = (0, _throttle2.default)(async () => {
      debug(`Schema change detected: re-inspecting schema...`);
      introspectionResultsByKind = await introspect();
      debug(`Schema change detected: re-inspecting schema complete`);
      triggerRebuild();
    }, 750, {
      leading: true,
      trailing: true
    });

    listener = async notification => {
      if (notification.channel !== "postgraphile_watch") {
        return;
      }
      try {
        const payload = JSON.parse(notification.payload);
        payload.payload = payload.payload || [];
        if (payload.type === "ddl") {
          const commands = payload.payload.filter(({ schema }) => schema == null || schemas.indexOf(schema) >= 0).map(({ command }) => command);
          if (commands.length) {
            handleChange();
          }
        } else if (payload.type === "drop") {
          const affectsOurSchemas = payload.payload.some(schemaName => schemas.indexOf(schemaName) >= 0);
          if (affectsOurSchemas) {
            handleChange();
          }
        } else {
          throw new Error(`Payload type '${payload.type}' not recognised`);
        }
      } catch (e) {
        debug(`Error occurred parsing notification payload: ${e}`);
      }
    };
    pgClient.on("notification", listener);
    introspectionResultsByKind = await introspect();
  }, stopListening);

  builder.hook("build", build => {
    return build.extend(build, {
      pgIntrospectionResultsByKind: introspectionResultsByKind
    });
  });
};
//# sourceMappingURL=PgIntrospectionPlugin.js.map