{"version":3,"sources":["../src/makeNewBuild.js"],"names":["makeNewBuild","graphql","recurseDataGeneratorsForFieldWarned","isString","str","isDev","indexOf","process","env","NODE_ENV","debug","hashCache","hashFieldAlias","precomputed","get","hash","update","digest","set","getSafeAliasFromAlias","alias","length","startsWith","Error","getSafeAliasFromResolveInfo","resolveInfo","getNameFromType","Type","GraphQLSchema","name","GraphQLInterfaceType","GraphQLObjectType","GraphQLInputObjectType","GraphQLEnumType","getNamedType","isCompositeType","isAbstractType","mergeData","data","gen","ReturnType","arg","results","ensureArray","result","k","Object","keys","value","newData","push","knownTypes","knownTypeNames","map","val","Array","isArray","ensureName","fn","displayName","enabled","console","trace","builder","allTypes","Int","GraphQLInt","Float","GraphQLFloat","String","GraphQLString","Boolean","GraphQLBoolean","ID","GraphQLID","allTypesSources","fieldDataGeneratorsByFieldNameByType","Map","fieldArgDataGeneratorsByFieldNameByType","graphileBuildVersion","version","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","getAliasFromResolveInfo","resolveAlias","_args","_context","addType","type","origin","newTypeSource","status","currentHookName","oldTypeSource","firstEntityDetails","chalk","magenta","secondEntityDetails","yellow","bold","getTypeByName","typeName","extend","newWithHooks","spec","inScope","performNonEmptyFieldsCheck","scope","warn","isFrozen","fieldDataGeneratorsByFieldName","fieldArgDataGeneratorsByFieldName","newSpec","applyHooks","addDataGeneratorForField","fieldName","Self","recurseDataGeneratorsForField","iKnowWhatIAmDoing","error","parsedResolveInfoFragment","rest","args","fields","StrippedType","argDataGeneratorsForSelfByFieldName","argDataGenerators","local","typeFields","getFields","field","gens","commonContext","assign","rawSpec","interfaces","interfacesContext","rawInterfaces","processedFields","fieldsContext","fieldWithHooks","fieldScope","context","addDataGenerator","addArgDataGenerator","getDataFromParsedResolveInfoFragment","e","finalSpec","FieldReturnType","returnType","rawFields","fieldsSpec","__origin","fieldSpec","autoField","values","reduce","memo","valueKey","newValue","_Self","isRootQuery","isProbablyAnEmptyObjectError","message","match","swallowError","fieldDataGeneratorsByType","inflection","pluralize","singularize","singular","upperCamelCase","camelCase","constantCase","resolveNode","currentHookEvent"],"mappings":"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","file":"makeNewBuild.js","sourcesContent":["// @flow\n\nimport * as graphql from \"graphql\";\nimport type {\n  GraphQLNamedType,\n  GraphQLInputField,\n  GraphQLFieldResolver,\n  GraphQLType,\n} from \"graphql\";\nimport {\n  parseResolveInfo,\n  simplifyParsedResolveInfoFragmentWithType,\n  getAliasFromResolveInfo as rawGetAliasFromResolveInfo,\n} from \"graphql-parse-resolve-info\";\nimport debugFactory from \"debug\";\nimport type { ResolveTree } from \"graphql-parse-resolve-info\";\nimport pluralize from \"pluralize\";\nimport LRUCache from \"lru-cache\";\nimport { upperCamelCase, camelCase, constantCase } from \"./utils\";\nimport swallowError from \"./swallowError\";\nimport resolveNode from \"./resolveNode\";\n\nimport type SchemaBuilder, {\n  Build,\n  Context,\n  Scope,\n  DataForType,\n} from \"./SchemaBuilder\";\n\nimport extend, { indent } from \"./extend\";\nimport chalk from \"chalk\";\nimport { createHash } from \"crypto\";\n\nimport { version } from \"../package.json\";\n\nlet recurseDataGeneratorsForFieldWarned = false;\n\nconst isString = str => typeof str === \"string\";\nconst isDev = [\"test\", \"development\"].indexOf(process.env.NODE_ENV) >= 0;\nconst debug = debugFactory(\"graphile-build\");\n\n/*\n * This should be more than enough for normal usage. If you come under a\n * sophisticated attack then the attacker can empty this of useful values (with\n * a lot of work) but because we use SHA1 hashes under the covers the aliases\n * will still be consistent even after the LRU cache is exhausted. And SHA1 can\n * produce half a million hashes per second on my machine, the LRU only gives\n * us a 10x speedup!\n */\nconst hashCache = LRUCache(100000);\n\n/*\n * This function must never return a string longer than 56 characters.\n *\n * This function must only output alphanumeric and underscore characters.\n *\n * Collisions in SHA1 aren't problematic here (for us; they will be problematic\n * for the user deliberately causing them, but that's their own fault!), so\n * we'll happily take the performance boost over SHA256.\n */\nfunction hashFieldAlias(str) {\n  const precomputed = hashCache.get(str);\n  if (precomputed) return precomputed;\n  const hash = createHash(\"sha1\")\n    .update(str)\n    .digest(\"hex\");\n  hashCache.set(str, hash);\n  return hash;\n}\n\n/*\n * This function may be replaced at any time, but all versions of it will\n * always return a representation of `alias` (a valid GraphQL identifier)\n * that:\n *\n *   1. won't conflict with normal GraphQL field names\n *   2. won't be over 60 characters long (allows for systems with alias length limits, such as PG)\n *   3. will give the same value when called multiple times within the same GraphQL query\n *   4. matches the regex /^[@!-_A-Za-z0-9]+$/\n *   5. will not be prefixed with `__` (as that will conflict with other Graphile internals)\n *\n * It does not guarantee that this alias will be human readable!\n */\nfunction getSafeAliasFromAlias(alias) {\n  if (alias.length <= 60 && !alias.startsWith(\"@\")) {\n    // Use the `@` to prevent conflicting with normal GraphQL field names, but otherwise let it through verbatim.\n    return `@${alias}`;\n  } else if (alias.length > 1024) {\n    throw new Error(\n      `GraphQL alias '${alias}' is too long, use shorter aliases (max length 1024).`\n    );\n  } else {\n    return `@@${hashFieldAlias(alias)}`;\n  }\n}\n\n/*\n * This provides a \"safe\" version of the alias from ResolveInfo, guaranteed to\n * never be longer than 60 characters. This makes it suitable as a PostgreSQL\n * identifier.\n */\nfunction getSafeAliasFromResolveInfo(resolveInfo) {\n  const alias = rawGetAliasFromResolveInfo(resolveInfo);\n  return getSafeAliasFromAlias(alias);\n}\n\ntype MetaData = {\n  [string]: Array<mixed>,\n};\ntype DataGeneratorFunction = (\n  parsedResolveInfoFragment: ResolveTree,\n  ReturnType: GraphQLType,\n  ...args: Array<mixed>\n) => Array<MetaData>;\n\ntype FieldSpecIsh = {\n  type?: GraphQLType,\n  args?: {},\n  resolve?: GraphQLFieldResolver<*, *>,\n  deprecationReason?: string,\n  description?: ?string,\n};\n\ntype ContextAndGenerators =\n  | Context\n  | {\n      addDataGenerator: DataGeneratorFunction => void,\n      addArgDataGenerator: DataGeneratorFunction => void,\n      getDataFromParsedResolveInfoFragment: (\n        parsedResolveInfoFragment: ResolveTree,\n        Type: GraphQLType\n      ) => DataForType,\n    };\n\nexport type FieldWithHooksFunction = (\n  fieldName: string,\n  spec: FieldSpecIsh | (ContextAndGenerators => FieldSpecIsh),\n  fieldScope?: {}\n) => {};\n\nexport type InputFieldWithHooksFunction = (\n  fieldName: string,\n  spec: GraphQLInputField,\n  fieldScope?: {}\n) => GraphQLInputField;\n\nfunction getNameFromType(Type: GraphQLNamedType | GraphQLSchema) {\n  if (Type instanceof GraphQLSchema) {\n    return \"schema\";\n  } else {\n    return Type.name;\n  }\n}\n\nconst {\n  GraphQLSchema,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n} = graphql;\n\nconst mergeData = (\n  data: MetaData,\n  gen: DataGeneratorFunction,\n  ReturnType,\n  arg\n) => {\n  const results: ?Array<MetaData> = ensureArray(gen(arg, ReturnType, data));\n  if (!results) {\n    return;\n  }\n  for (const result: MetaData of results) {\n    for (const k of Object.keys(result)) {\n      data[k] = data[k] || [];\n      const value: mixed = result[k];\n      const newData: ?Array<mixed> = ensureArray(value);\n      if (newData) {\n        data[k].push(...newData);\n      }\n    }\n  }\n};\n\nconst knownTypes = [\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n];\nconst knownTypeNames = knownTypes.map(k => k.name);\n\nfunction ensureArray<T>(val: void | Array<T> | T): void | Array<T> {\n  if (val == null) {\n    return;\n  } else if (Array.isArray(val)) {\n    return val;\n  } else {\n    return [val];\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nlet ensureName = fn => {};\nif ([\"development\", \"test\"].indexOf(process.env.NODE_ENV) >= 0) {\n  ensureName = fn => {\n    if (isDev && !fn.displayName && !fn.name && debug.enabled) {\n      // eslint-disable-next-line no-console\n      console.trace(\n        \"WARNING: you've added a function with no name as an argDataGenerator, doing so may make debugging more challenging\"\n      );\n    }\n  };\n}\n\nexport default function makeNewBuild(builder: SchemaBuilder): { ...Build } {\n  const allTypes = {\n    Int: graphql.GraphQLInt,\n    Float: graphql.GraphQLFloat,\n    String: graphql.GraphQLString,\n    Boolean: graphql.GraphQLBoolean,\n    ID: graphql.GraphQLID,\n  };\n  const allTypesSources = {\n    Int: \"GraphQL Built-in\",\n    Float: \"GraphQL Built-in\",\n    String: \"GraphQL Built-in\",\n    Boolean: \"GraphQL Built-in\",\n    ID: \"GraphQL Built-in\",\n  };\n\n  // Every object type gets fieldData associated with each of its\n  // fields.\n\n  // When a field is defined, it may add to this field data.\n\n  // When something resolves referencing this type, the resolver may\n  // request the fieldData, e.g. to perform optimisations.\n\n  // fieldData is an object whose keys are the fields on this\n  // GraphQLObjectType and whose values are an object (whose keys are\n  // arbitrary namespaced keys and whose values are arrays of\n  // information of this kind)\n  const fieldDataGeneratorsByFieldNameByType = new Map();\n  const fieldArgDataGeneratorsByFieldNameByType = new Map();\n\n  return {\n    graphileBuildVersion: version,\n    graphql,\n    parseResolveInfo,\n    simplifyParsedResolveInfoFragmentWithType,\n    getSafeAliasFromAlias,\n    getAliasFromResolveInfo: getSafeAliasFromResolveInfo, // DEPRECATED: do not use this!\n    getSafeAliasFromResolveInfo,\n    resolveAlias(data, _args, _context, resolveInfo) {\n      const alias = getSafeAliasFromResolveInfo(resolveInfo);\n      return data[alias];\n    },\n    addType(type: GraphQLNamedType, origin?: ?string): void {\n      if (!type.name) {\n        throw new Error(\n          `addType must only be called with named types, try using require('graphql').getNamedType`\n        );\n      }\n      const newTypeSource =\n        origin ||\n        // 'this' is typically only available after the build is finalized\n        (this\n          ? `'addType' call during hook '${this.status.currentHookName}'`\n          : null);\n      if (allTypes[type.name]) {\n        if (allTypes[type.name] !== type) {\n          const oldTypeSource = allTypesSources[type.name];\n          const firstEntityDetails = !oldTypeSource\n            ? \"The first type was registered from an unknown origin.\"\n            : `The first entity was:\\n\\n${indent(\n                chalk.magenta(oldTypeSource)\n              )}`;\n          const secondEntityDetails = !newTypeSource\n            ? \"The second type was registered from an unknown origin.\"\n            : `The second entity was:\\n\\n${indent(\n                chalk.yellow(newTypeSource)\n              )}`;\n          throw new Error(\n            `A type naming conflict has occurred - two entities have tried to define the same type '${chalk.bold(\n              type.name\n            )}'.\\n\\n${indent(firstEntityDetails)}\\n\\n${indent(\n              secondEntityDetails\n            )}`\n          );\n        }\n      } else {\n        allTypes[type.name] = type;\n        allTypesSources[type.name] = newTypeSource;\n      }\n    },\n    getTypeByName(typeName) {\n      return allTypes[typeName];\n    },\n    extend,\n    newWithHooks<T: GraphQLNamedType | GraphQLSchema, ConfigType: *>(\n      Type: Class<T>,\n      spec: ConfigType,\n      inScope: Scope,\n      performNonEmptyFieldsCheck = false\n    ): ?T {\n      const scope = inScope || {};\n      if (!inScope) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `No scope was provided to new ${Type.name}[name=${\n            spec.name\n          }], it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`\n        );\n      }\n      if (!Type) {\n        throw new Error(\"No type specified!\");\n      }\n      if (!this.newWithHooks || !Object.isFrozen(this)) {\n        throw new Error(\n          \"Please do not generate the schema during the build building phase, use 'init' instead\"\n        );\n      }\n      const fieldDataGeneratorsByFieldName = {};\n      const fieldArgDataGeneratorsByFieldName = {};\n      let newSpec = spec;\n      if (\n        knownTypes.indexOf(Type) === -1 &&\n        knownTypeNames.indexOf(Type.name) >= 0\n      ) {\n        throw new Error(\n          `GraphQL conflict for '${\n            Type.name\n          }' detected! Multiple versions of graphql exist in your node_modules?`\n        );\n      }\n      if (Type === GraphQLSchema) {\n        newSpec = builder.applyHooks(this, \"GraphQLSchema\", newSpec, {\n          type: \"GraphQLSchema\",\n          scope,\n        });\n      } else if (Type === GraphQLObjectType) {\n        const addDataGeneratorForField = (\n          fieldName,\n          fn: DataGeneratorFunction\n        ) => {\n          fn.displayName =\n            fn.displayName ||\n            `${getNameFromType(Self)}:${fieldName}[${fn.name || \"anonymous\"}]`;\n          fieldDataGeneratorsByFieldName[fieldName] =\n            fieldDataGeneratorsByFieldName[fieldName] || [];\n          fieldDataGeneratorsByFieldName[fieldName].push(fn);\n        };\n        const recurseDataGeneratorsForField = (\n          fieldName,\n          iKnowWhatIAmDoing\n        ) => {\n          /*\n           * Recursing data generators is not safe in general; however there\n           * are certain exceptions - for example when you know there are no\n           * \"dynamic\" data generator fields - e.g. where the GraphQL alias is\n           * not used at all. In PostGraphile the only case of this is the\n           * PageInfo object as none of the fields accept arguments, and they\n           * do not rely on the GraphQL query alias to store the result.\n           */\n          if (!iKnowWhatIAmDoing && !recurseDataGeneratorsForFieldWarned) {\n            recurseDataGeneratorsForFieldWarned = true;\n            // eslint-disable-next-line no-console\n            console.error(\n              \"Use of `recurseDataGeneratorsForField` is NOT SAFE. e.g. `{n1: node { a: field1 }, n2: node { a: field2 } }` cannot resolve correctly.\"\n            );\n          }\n          const fn = (parsedResolveInfoFragment, ReturnType, ...rest) => {\n            const { args } = parsedResolveInfoFragment;\n            const { fields } = this.simplifyParsedResolveInfoFragmentWithType(\n              parsedResolveInfoFragment,\n              ReturnType\n            );\n            const results = [];\n            const StrippedType: GraphQLNamedType = getNamedType(ReturnType);\n            const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n              StrippedType\n            );\n            const argDataGeneratorsForSelfByFieldName = fieldArgDataGeneratorsByFieldNameByType.get(\n              Self\n            );\n            if (argDataGeneratorsForSelfByFieldName) {\n              const argDataGenerators =\n                argDataGeneratorsForSelfByFieldName[fieldName];\n              for (const gen of argDataGenerators) {\n                const local = ensureArray(gen(args, ReturnType, ...rest));\n                if (local) {\n                  results.push(...local);\n                }\n              }\n            }\n            if (\n              fieldDataGeneratorsByFieldName &&\n              isCompositeType(StrippedType) &&\n              !isAbstractType(StrippedType)\n            ) {\n              const typeFields = StrippedType.getFields();\n              for (const alias of Object.keys(fields)) {\n                const field = fields[alias];\n                // Run generators with `field` as the `parsedResolveInfoFragment`, pushing results to `results`\n                const gens = fieldDataGeneratorsByFieldName[field.name];\n                if (gens) {\n                  for (const gen of gens) {\n                    const local = ensureArray(\n                      gen(field, typeFields[field.name].type, ...rest)\n                    );\n                    if (local) {\n                      results.push(...local);\n                    }\n                  }\n                }\n              }\n            }\n            return results;\n          };\n          fn.displayName = `recurseDataGeneratorsForField(${getNameFromType(\n            Self\n          )}:${fieldName})`;\n          addDataGeneratorForField(fieldName, fn);\n          // get type from field, get\n        };\n\n        const commonContext = {\n          type: \"GraphQLObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLObjectType\",\n          newSpec,\n          Object.assign({}, commonContext, {\n            addDataGeneratorForField,\n            recurseDataGeneratorsForField,\n          }),\n          `|${newSpec.name}`\n        );\n\n        const rawSpec = newSpec;\n        newSpec = Object.assign({}, newSpec, {\n          interfaces: () => {\n            const interfacesContext = Object.assign({}, commonContext, {\n              Self,\n              GraphQLObjectType: rawSpec,\n            });\n            let rawInterfaces = rawSpec.interfaces || [];\n            if (typeof rawInterfaces === \"function\") {\n              rawInterfaces = rawInterfaces(interfacesContext);\n            }\n            return builder.applyHooks(\n              this,\n              \"GraphQLObjectType:interfaces\",\n              rawInterfaces,\n              interfacesContext,\n              `|${getNameFromType(Self)}`\n            );\n          },\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = Object.assign({}, commonContext, {\n              addDataGeneratorForField,\n              recurseDataGeneratorsForField,\n              Self,\n              GraphQLObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.\"\n                  );\n                }\n                if (!fieldScope) {\n                  throw new Error(\n                    \"All calls to `fieldWithHooks` must specify a `fieldScope` \" +\n                      \"argument that gives additional context about the field so \" +\n                      \"that further plugins may more easily understand the field. \" +\n                      \"Keys within this object should contain the phrase 'field' \" +\n                      \"since they will be merged into the parent objects scope and \" +\n                      \"are not allowed to clash. If you really have no additional \" +\n                      \"information to give, please just pass `{}`.\"\n                  );\n                }\n\n                let argDataGenerators = [];\n                fieldArgDataGeneratorsByFieldName[\n                  fieldName\n                ] = argDataGenerators;\n\n                let newSpec = spec;\n                let context = Object.assign({}, commonContext, {\n                  Self,\n                  addDataGenerator(fn) {\n                    return addDataGeneratorForField(fieldName, fn);\n                  },\n                  addArgDataGenerator(fn) {\n                    ensureName(fn);\n                    argDataGenerators.push(fn);\n                  },\n                  getDataFromParsedResolveInfoFragment: (\n                    parsedResolveInfoFragment,\n                    ReturnType\n                  ): DataForType => {\n                    const Type: GraphQLNamedType = getNamedType(ReturnType);\n                    const data = {};\n\n                    const {\n                      fields,\n                      args,\n                    } = this.simplifyParsedResolveInfoFragmentWithType(\n                      parsedResolveInfoFragment,\n                      ReturnType\n                    );\n\n                    // Args -> argDataGenerators\n                    for (const gen of argDataGenerators) {\n                      try {\n                        mergeData(data, gen, ReturnType, args);\n                      } catch (e) {\n                        debug(\n                          \"Failed to execute argDataGenerator '%s' on %s of %s\",\n                          gen.displayName || gen.name || \"anonymous\",\n                          fieldName,\n                          getNameFromType(Self)\n                        );\n                        throw e;\n                      }\n                    }\n\n                    // finalSpec.type -> fieldData\n                    if (!finalSpec) {\n                      throw new Error(\n                        \"It's too early to call this! Call from within resolve\"\n                      );\n                    }\n                    const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n                      Type\n                    );\n                    if (\n                      fieldDataGeneratorsByFieldName &&\n                      isCompositeType(Type) &&\n                      !isAbstractType(Type)\n                    ) {\n                      const typeFields = Type.getFields();\n                      for (const alias of Object.keys(fields)) {\n                        const field = fields[alias];\n                        const gens = fieldDataGeneratorsByFieldName[field.name];\n                        if (gens) {\n                          const FieldReturnType = typeFields[field.name].type;\n                          for (const gen of gens) {\n                            mergeData(data, gen, FieldReturnType, field);\n                          }\n                        }\n                      }\n                    }\n                    return data;\n                  },\n                  scope: extend(\n                    extend(\n                      { ...scope },\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLObjectType '${rawSpec.name}'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLObjectType '${\n                      rawSpec.name\n                    }'`\n                  ),\n                });\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                newSpec.args = newSpec.args || {};\n                newSpec = Object.assign({}, newSpec, {\n                  args: builder.applyHooks(\n                    this,\n                    \"GraphQLObjectType:fields:field:args\",\n                    newSpec.args,\n                    Object.assign({}, context, {\n                      field: newSpec,\n                      returnType: newSpec.type,\n                    }),\n                    `|${getNameFromType(Self)}.fields.${fieldName}`\n                  ),\n                });\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: FieldWithHooksFunction),\n            });\n            let rawFields = rawSpec.fields || {};\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLObjectType:fields\",\n              this.extend(\n                {},\n                rawFields,\n                `Default field included in newWithHooks call for '${\n                  rawSpec.name\n                }'. ${inScope.__origin || \"\"}`\n              ),\n              fieldsContext,\n              `|${rawSpec.name}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        });\n      } else if (Type === GraphQLInputObjectType) {\n        const commonContext = {\n          type: \"GraphQLInputObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLInputObjectType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        newSpec.fields = newSpec.fields || {};\n\n        const rawSpec = newSpec;\n        newSpec = Object.assign({}, newSpec, {\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = Object.assign({}, commonContext, {\n              Self,\n              GraphQLInputObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope = {}) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.\"\n                  );\n                }\n                let context = Object.assign({}, commonContext, {\n                  Self,\n                  scope: extend(\n                    extend(\n                      { ...scope },\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLInputObjectType '${\n                        rawSpec.name\n                      }'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${\n                      rawSpec.name\n                    }'`\n                  ),\n                });\n                let newSpec = spec;\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLInputObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: InputFieldWithHooksFunction),\n            });\n            let rawFields = rawSpec.fields;\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLInputObjectType:fields\",\n              this.extend(\n                {},\n                rawFields,\n                `Default field included in newWithHooks call for '${\n                  rawSpec.name\n                }'. ${inScope.__origin || \"\"}`\n              ),\n              fieldsContext,\n              `|${getNameFromType(Self)}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        });\n      } else if (Type === GraphQLEnumType) {\n        const commonContext = {\n          type: \"GraphQLEnumType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLEnumType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n\n        newSpec.values = builder.applyHooks(\n          this,\n          \"GraphQLEnumType:values\",\n          newSpec.values,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        const values = newSpec.values;\n        newSpec.values = Object.keys(values).reduce((memo, valueKey) => {\n          const value = values[valueKey];\n          const newValue = builder.applyHooks(\n            this,\n            \"GraphQLEnumType:values:value\",\n            value,\n            commonContext,\n            `|${newSpec.name}|${valueKey}`\n          );\n          memo[valueKey] = newValue;\n          return memo;\n        }, {});\n      }\n      const finalSpec: ConfigType = newSpec;\n\n      const Self: T = new Type(finalSpec);\n      if (!(Self instanceof GraphQLSchema) && performNonEmptyFieldsCheck) {\n        try {\n          if (\n            Self instanceof GraphQLInterfaceType ||\n            Self instanceof GraphQLObjectType ||\n            Self instanceof GraphQLInputObjectType\n          ) {\n            const _Self:\n              | GraphQLInterfaceType\n              | GraphQLInputObjectType\n              | GraphQLObjectType = Self;\n            if (typeof _Self.getFields === \"function\") {\n              const fields = _Self.getFields();\n              if (Object.keys(fields).length === 0) {\n                // We require there's at least one field on GraphQLObjectType and GraphQLInputObjectType records\n                return null;\n              }\n            }\n          }\n        } catch (e) {\n          // This is the error we're expecting to handle:\n          // https://github.com/graphql/graphql-js/blob/831598ba76f015078ecb6c5c1fbaf133302f3f8e/src/type/definition.js#L526-L531\n          if (inScope && inScope.isRootQuery) {\n            throw e;\n          }\n          const isProbablyAnEmptyObjectError = !!e.message.match(\n            /function which returns such an object/\n          );\n          if (!isProbablyAnEmptyObjectError) {\n            this.swallowError(e);\n          }\n          return null;\n        }\n      }\n\n      if (finalSpec.name) {\n        this.addType(\n          Self,\n          scope.__origin ||\n            (this\n              ? `'newWithHooks' call during hook '${\n                  this.status.currentHookName\n                }'`\n              : null)\n        );\n      }\n      fieldDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldDataGeneratorsByFieldName\n      );\n      fieldArgDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldArgDataGeneratorsByFieldName\n      );\n      return Self;\n    },\n    fieldDataGeneratorsByType: fieldDataGeneratorsByFieldNameByType, // @deprecated\n    fieldDataGeneratorsByFieldNameByType,\n    fieldArgDataGeneratorsByFieldNameByType,\n    inflection: {\n      pluralize,\n      singularize: pluralize.singular,\n      upperCamelCase,\n      camelCase,\n      constantCase,\n    },\n    swallowError,\n    // resolveNode: EXPERIMENTAL, API might change!\n    resolveNode,\n    status: {\n      currentHookName: null,\n      currentHookEvent: null,\n    },\n  };\n}\n"]}