{"version":3,"sources":["../src/SchemaBuilder.js"],"names":["graphql","GraphQLSchema","debug","INDENT","SchemaBuilder","EventEmitter","constructor","_busy","_watching","watchers","unwatchers","depth","hooks","build","inflection","init","GraphQLObjectType","GraphQLInputObjectType","GraphQLEnumType","_setPluginName","name","_currentPluginName","hook","hookName","fn","Error","displayName","push","applyHooks","input","context","debugStr","repeat","newObj","hookDisplayName","previousHookName","status","currentHookName","previousHookEvent","currentHookEvent","registerWatcher","listen","unlisten","createBuild","initialBuild","scope","Object","keys","filter","key","freeze","buildSchema","_generatedSchema","newWithHooks","__origin","isSchema","watchSchema","listener","_explicitSchemaListener","triggerChange","schema","emit","e","console","error","on","unwatchSchema","removeListener"],"mappings":";;;;;;AACA;;;;AACA;;;;AACA;;AACA;;IAAYA,O;;AAOZ;;;;;;;;AACA;AACA;AAQA,MAAM,EAAEC,aAAF,KAAoBD,OAA1B;;;AAEA,MAAME,QAAQ,qBAAa,kBAAb,CAAd;;AAEA,MAAMC,SAAS,IAAf;;AAkGA,MAAMC,aAAN,SAA4BC,gBAA5B,CAAyC;;AAevCC,gBAAc;AACZ;;AAEA,SAAKC,KAAL,GAAa,KAAb;AACA,SAAKC,SAAL,GAAiB,KAAjB;;AAEA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,UAAL,GAAkB,EAAlB;;AAEA;AACA,SAAKC,KAAL,GAAa,CAAC,CAAd;;AAEA,SAAKC,KAAL,GAAa;AACX;AACA;AACAC,aAAO,EAHI;;AAKX;AACA;AACAC,kBAAY,EAPD;;AASX;AACA;AACA;AACAC,YAAM,EAZK;;AAcX;AACAd,qBAAe,EAfJ;;AAiBX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAe,yBAAmB,EA1BR;AA2BX,sCAAgC,EA3BrB;AA4BX,kCAA4B,EA5BjB;AA6BX,wCAAkC,EA7BvB;AA8BX,6CAAuC,EA9B5B;;AAgCX;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,8BAAwB,EAvCb;AAwCX,uCAAiC,EAxCtB;AAyCX,6CAAuC,EAzC5B;;AA2CX;AACA;AACA;AACA;AACA;AACAC,uBAAiB,EAhDN;AAiDX,gCAA0B,EAjDf;AAkDX,sCAAgC;AAlDrB,KAAb;AAoDD;;AAEDC,iBAAeC,IAAf,EAA8B;AAC5B,SAAKC,kBAAL,GAA0BD,IAA1B;AACD;;AAED;;;;;;;;AAQAE,OAAWC,QAAX,EAA6BC,EAA7B,EAAgD;AAC9C,QAAI,CAAC,KAAKZ,KAAL,CAAWW,QAAX,CAAL,EAA2B;AACzB,YAAM,IAAIE,KAAJ,CAAW,WAAUF,QAAS,2BAA9B,CAAN;AACD;AACD,QAAI,KAAKF,kBAAL,IAA2B,CAACG,GAAGE,WAAnC,EAAgD;AAC9CF,SAAGE,WAAH,GAAkB,GAChB,KAAKL,kBACN,IAAGE,QAAS,IAAGC,GAAGE,WAAH,IAAkBF,GAAGJ,IAArB,IAA6B,WAAY,EAFzD;AAGD;AACD,SAAKR,KAAL,CAAWW,QAAX,EAAqBI,IAArB,CAA0BH,EAA1B;AACD;;AAEDI,aACEf,KADF,EAEEU,QAFF,EAGEM,KAHF,EAIEC,OAJF,EAKEC,WAAmB,EALrB,EAMK;AACH,QAAI,CAACF,KAAL,EAAY;AACV,YAAM,IAAIJ,KAAJ,CAAU,wCAAV,CAAN;AACD;AACD,SAAKd,KAAL;AACA,QAAI;AACFT,YAAO,GAAEC,OAAO6B,MAAP,CAAc,KAAKrB,KAAnB,CAA0B,IAAGY,QAAS,GAAEQ,QAAS,eAA1D;;AAEA,YAAMnB,QAA8B,KAAKA,KAAL,CAAWW,QAAX,CAApC;AACA,UAAI,CAACX,KAAL,EAAY;AACV,cAAM,IAAIa,KAAJ,CAAW,WAAUF,QAAS,4BAA9B,CAAN;AACD;;AAED,UAAIU,SAASJ,KAAb;AACA,WAAK,MAAMP,IAAX,IAAkCV,KAAlC,EAAyC;AACvC,aAAKD,KAAL;AACA,YAAI;AACF,gBAAMuB,kBAAkBZ,KAAKI,WAAL,IAAoBJ,KAAKF,IAAzB,IAAiC,WAAzD;AACAlB,gBACG,GAAEC,OAAO6B,MAAP,CACD,KAAKrB,KADJ,CAED,IAAGY,QAAS,GAAEQ,QAAS,mBAAkBG,eAAgB,GAH7D;;AAMA,gBAAMC,mBAAmBtB,MAAMuB,MAAN,CAAaC,eAAtC;AACA,gBAAMC,oBAAoBzB,MAAMuB,MAAN,CAAaG,gBAAvC;AACA1B,gBAAMuB,MAAN,CAAaC,eAAb,GAA+BH,eAA/B;AACArB,gBAAMuB,MAAN,CAAaG,gBAAb,GAAgChB,QAAhC;AACAU,mBAASX,KAAKW,MAAL,EAAapB,KAAb,EAAoBiB,OAApB,CAAT;AACAjB,gBAAMuB,MAAN,CAAaC,eAAb,GAA+BF,gBAA/B;AACAtB,gBAAMuB,MAAN,CAAaG,gBAAb,GAAgCD,iBAAhC;;AAEA,cAAI,CAACL,MAAL,EAAa;AACX,kBAAM,IAAIR,KAAJ,CACH,SAAQH,KAAKI,WAAL,IACPJ,KAAKF,IADE,IAEP,WAAY,UAASG,QAAS,2BAA0BU,MAAO,GAH7D,CAAN;AAKD;AACD/B,gBACG,GAAEC,OAAO6B,MAAP,CACD,KAAKrB,KADJ,CAED,IAAGY,QAAS,GAAEQ,QAAS,SAAQG,eAAgB,YAHnD;AAKD,SA5BD,SA4BU;AACR,eAAKvB,KAAL;AACD;AACF;;AAEDT,YAAO,GAAEC,OAAO6B,MAAP,CAAc,KAAKrB,KAAnB,CAA0B,IAAGY,QAAS,GAAEQ,QAAS,aAA1D;;AAEA,aAAOE,MAAP;AACD,KA/CD,SA+CU;AACR,WAAKtB,KAAL;AACD;AACF;;AAED6B,kBAAgBC,MAAhB,EAAsCC,QAAtC,EAA8D;AAC5D,QAAI,CAACD,MAAD,IAAW,CAACC,QAAhB,EAA0B;AACxB,YAAM,IAAIjB,KAAJ,CAAU,oDAAV,CAAN;AACD;AACD,SAAKhB,QAAL,CAAckB,IAAd,CAAmBc,MAAnB;AACA,SAAK/B,UAAL,CAAgBiB,IAAhB,CAAqBe,QAArB;AACD;;AAEDC,gBAA4B;AAC1B,UAAMC,eAAe,4BAAa,IAAb,CAArB;AACA;AACAA,iBAAa9B,UAAb,GAA0B,KAAKc,UAAL,CACxBgB,YADwB,EAExB,YAFwB,EAGxBA,aAAa9B,UAHW,EAIxB;AACE+B,aAAO;AADT,KAJwB,CAA1B;AAQA,UAAMhC,QAAQ,KAAKe,UAAL,CAAgBgB,YAAhB,EAA8B,OAA9B,EAAuCA,YAAvC,EAAqD;AACjEC,aAAO;AAD0D,KAArD,CAAd;AAGA;AACA,wBACEhC,KADF,EAEEiC,OAAOC,IAAP,CAAYlC,KAAZ,EAAmBmC,MAAnB,CAA0BC,OAAO,OAAOpC,MAAMoC,GAAN,CAAP,KAAsB,UAAvD,CAFF;AAIAH,WAAOI,MAAP,CAAcrC,KAAd;AACA,SAAKe,UAAL,CAAgBf,KAAhB,EAAuB,MAAvB,EAA+B,EAA/B,EAAmC,EAAEgC,OAAO,EAAT,EAAnC;AACA,WAAOhC,KAAP;AACD;;AAEDsC,gBAA6B;AAC3B,QAAI,CAAC,KAAKC,gBAAV,EAA4B;AAC1B,YAAMvC,QAAQ,KAAK8B,WAAL,EAAd;AACA,WAAKS,gBAAL,GAAwBvC,MAAMwC,YAAN,CACtBpD,aADsB,EAEtB,EAFsB,EAGtB;AACEqD,kBAAW,kBADb;AAEEC,kBAAU;AAFZ,OAHsB,CAAxB;AAQD;AACD,QAAI,CAAC,KAAKH,gBAAV,EAA4B;AAC1B,YAAM,IAAI3B,KAAJ,CAAU,0BAAV,CAAN;AACD;AACD,WAAO,KAAK2B,gBAAZ;AACD;;AAED,QAAMI,WAAN,CAAkBC,QAAlB,EAA6C;AAC3C,QAAI,KAAKlD,KAAT,EAAgB;AACd,YAAM,IAAIkB,KAAJ,CAAU,6BAAV,CAAN;AACD;AACD,QAAI,KAAKjB,SAAT,EAAoB;AAClB,YAAM,IAAIiB,KAAJ,CACJ,mFADI,CAAN;AAGD;AACD,QAAI;AACF,WAAKlB,KAAL,GAAa,IAAb;AACA,WAAKmD,uBAAL,GAA+BD,QAA/B;AACA,WAAKE,aAAL,GAAqB,MAAM;AACzB,aAAKP,gBAAL,GAAwB,IAAxB;AACA;AACA,YAAI;AACF,gBAAMQ,SAAS,KAAKT,WAAL,EAAf;AACA,eAAKU,IAAL,CAAU,QAAV,EAAoBD,MAApB;AACD,SAHD,CAGE,OAAOE,CAAP,EAAU;AACV;AACA;AACA;AACAC,kBAAQC,KAAR,CACE,4DADF;AAGA;AACAD,kBAAQC,KAAR,CAAcF,CAAd;AACD;AACF,OAhBD;AAiBA,WAAK,MAAMtC,EAAX,IAAiB,KAAKf,QAAtB,EAAgC;AAC9B,cAAMe,GAAG,KAAKmC,aAAR,CAAN;AACD;AACD,UAAIF,QAAJ,EAAc;AACZ,aAAKQ,EAAL,CAAQ,QAAR,EAAkBR,QAAlB;AACD;AACD,WAAKI,IAAL,CAAU,QAAV,EAAoB,KAAKV,WAAL,EAApB;AACA,WAAK3C,SAAL,GAAiB,IAAjB;AACD,KA5BD,SA4BU;AACR,WAAKD,KAAL,GAAa,KAAb;AACD;AACF;;AAED,QAAM2D,aAAN,GAAsB;AACpB,QAAI,KAAK3D,KAAT,EAAgB;AACd,YAAM,IAAIkB,KAAJ,CAAU,6BAAV,CAAN;AACD;AACD,QAAI,CAAC,KAAKjB,SAAV,EAAqB;AACnB,YAAM,IAAIiB,KAAJ,CAAU,iCAAV,CAAN;AACD;AACD,SAAKlB,KAAL,GAAa,IAAb;AACA,QAAI;AACF,YAAMkD,WAAW,KAAKC,uBAAtB;AACA,WAAKA,uBAAL,GAA+B,IAA/B;AACA,UAAID,QAAJ,EAAc;AACZ,aAAKU,cAAL,CAAoB,QAApB,EAA8BV,QAA9B;AACD;AACD,UAAI,KAAKE,aAAT,EAAwB;AACtB,aAAK,MAAMnC,EAAX,IAAiB,KAAKd,UAAtB,EAAkC;AAChC,gBAAMc,GAAG,KAAKmC,aAAR,CAAN;AACD;AACF;AACD,WAAKA,aAAL,GAAqB,IAArB;AACA,WAAKnD,SAAL,GAAiB,KAAjB;AACD,KAbD,SAaU;AACR,WAAKD,KAAL,GAAa,KAAb;AACD;AACF;AA5RsC;;kBA+R1BH,a","file":"SchemaBuilder.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport makeNewBuild from \"./makeNewBuild\";\nimport { bindAll } from \"./utils\";\nimport * as graphql from \"graphql\";\nimport type {\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInterfaceType,\n  GraphQLObjectTypeConfig,\n} from \"graphql\";\nimport EventEmitter from \"events\";\n// TODO: when we move to TypeScript, change this to:\n// import { EventEmitter } from \"events\";\nimport type {\n  simplifyParsedResolveInfoFragmentWithType,\n  parseResolveInfo,\n} from \"graphql-parse-resolve-info\";\nimport type { GraphQLResolveInfo } from \"graphql/type/definition\";\n\nimport type { FieldWithHooksFunction } from \"./makeNewBuild\";\nconst { GraphQLSchema } = graphql;\n\nconst debug = debugFactory(\"graphile-builder\");\n\nconst INDENT = \"  \";\n\nexport type Options = {\n  [string]: mixed,\n};\n\nexport type Plugin = (\n  builder: SchemaBuilder,\n  options: Options\n) => Promise<void> | void;\n\ntype TriggerChangeType = () => void;\n\nexport type DataForType = {\n  [string]: Array<mixed>,\n};\n\nexport type Build = {|\n  graphileBuildVersion: string,\n  graphql: *,\n  parseResolveInfo: parseResolveInfo,\n  simplifyParsedResolveInfoFragmentWithType: simplifyParsedResolveInfoFragmentWithType,\n  // DEPRECATED: getAliasFromResolveInfo: (resolveInfo: GraphQLResolveInfo) => string,\n  getSafeAliasFromResolveInfo: (resolveInfo: GraphQLResolveInfo) => string,\n  getSafeAliasFromAlias: (alias: string) => string,\n  resolveAlias(\n    data: {},\n    _args: mixed,\n    _context: mixed,\n    resolveInfo: GraphQLResolveInfo\n  ): string,\n  addType(type: GraphQLNamedType, origin?: ?string): void,\n  getTypeByName(typeName: string): ?GraphQLType,\n  extend<Obj1: *, Obj2: *>(base: Obj1, extra: Obj2, hint?: string): Obj1 & Obj2,\n  newWithHooks<T: GraphQLNamedType | GraphQLSchema, ConfigType: *>(\n    Class<T>,\n    spec: ConfigType,\n    scope: Scope,\n    performNonEmptyFieldsCheck?: boolean\n  ): ?T,\n  fieldDataGeneratorsByType: Map<*, *>, // @deprecated - use fieldDataGeneratorsByFieldNameByType instead\n  fieldDataGeneratorsByFieldNameByType: Map<*, *>,\n  fieldArgDataGeneratorsByFieldNameByType: Map<*, *>,\n  inflection: {\n    // eslint-disable-next-line flowtype/no-weak-types\n    [string]: (...args: Array<any>) => string,\n  },\n  swallowError: (e: Error) => void,\n  status: {\n    currentHookName: ?string,\n    currentHookEvent: ?string,\n  },\n|};\n\nexport type BuildExtensionQuery = {|\n  $$isQuery: Symbol,\n|};\n\nexport type Scope = {\n  __origin: ?string,\n  [string]: mixed,\n};\n\nexport type Context = {|\n  scope: Scope,\n  type: string,\n  [string]: mixed,\n|};\n\ntype DataGeneratorFunction = () => {};\n\nexport type ContextGraphQLObjectTypeFields = {|\n  addDataGeneratorForField: (\n    fieldName: string,\n    fn: DataGeneratorFunction\n  ) => void,\n  recurseDataGeneratorsForField: (fieldName: string) => void, // @deprecated - DO NOT USE!\n  Self: GraphQLNamedType,\n  GraphQLObjectType: GraphQLObjectTypeConfig<*, *>,\n  fieldWithHooks: FieldWithHooksFunction,\n|};\n\ntype SupportedHookTypes = {} | Build | Array<GraphQLInterfaceType>;\n\nexport type Hook<\n  Type: SupportedHookTypes,\n  BuildExtensions: *,\n  ContextExtensions: *\n> = (\n  input: Type,\n  build: { ...Build, ...BuildExtensions },\n  context: { ...Context, ...ContextExtensions }\n) => Type;\n\nexport type WatchUnwatch = (triggerChange: TriggerChangeType) => void;\n\nexport type SchemaListener = (newSchema: GraphQLSchema) => void;\n\nclass SchemaBuilder extends EventEmitter {\n  watchers: Array<WatchUnwatch>;\n  unwatchers: Array<WatchUnwatch>;\n  triggerChange: ?TriggerChangeType;\n  depth: number;\n  hooks: {\n    [string]: Array<Hook<*, *, *>>,\n  };\n\n  _currentPluginName: ?string;\n  _generatedSchema: ?GraphQLSchema;\n  _explicitSchemaListener: ?SchemaListener;\n  _busy: boolean;\n  _watching: boolean;\n\n  constructor() {\n    super();\n\n    this._busy = false;\n    this._watching = false;\n\n    this.watchers = [];\n    this.unwatchers = [];\n\n    // Because hooks can nest, this keeps track of how deep we are.\n    this.depth = -1;\n\n    this.hooks = {\n      // The build object represents the current schema build and is passed to\n      // all hooks, hook the 'build' event to extend this object:\n      build: [],\n\n      // Inflection is used for naming resulting types/fields/args/etc - it's\n      // hookable so that other plugins may extend it or override it\n      inflection: [],\n\n      // 'build' phase should not generate any GraphQL objects (because the\n      // build object isn't finalised yet so it risks weirdness occurring); so\n      // if you need to set up any global types you can do so here.\n      init: [],\n\n      // Add 'query', 'mutation' or 'subscription' types in this hook:\n      GraphQLSchema: [],\n\n      // When creating a GraphQLObjectType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLObjectType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLObjectType:interfaces' to add additional interfaces to this object type\n      // - 'GraphQLObjectType:fields' to add additional fields to this object type (is\n      //   ran asynchronously and gets a reference to the final GraphQL Object as\n      //   `Self` in the context)\n      // - 'GraphQLObjectType:fields:field' to customise an individual field from above\n      // - 'GraphQLObjectType:fields:field:args' to customize the arguments to a field\n      GraphQLObjectType: [],\n      \"GraphQLObjectType:interfaces\": [],\n      \"GraphQLObjectType:fields\": [],\n      \"GraphQLObjectType:fields:field\": [],\n      \"GraphQLObjectType:fields:field:args\": [],\n\n      // When creating a GraphQLInputObjectType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLInputObjectType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLInputObjectType:fields' to add additional fields to this object type (is\n      //   ran asynchronously and gets a reference to the final GraphQL Object as\n      //   `Self` in the context)\n      // - 'GraphQLInputObjectType:fields:field' to customise an individual field from above\n      GraphQLInputObjectType: [],\n      \"GraphQLInputObjectType:fields\": [],\n      \"GraphQLInputObjectType:fields:field\": [],\n\n      // When creating a GraphQLEnumType via `newWithHooks`, we'll\n      // execute, the following hooks:\n      // - 'GraphQLEnumType' to add any root-level attributes, e.g. add a description\n      // - 'GraphQLEnumType:values' to add additional values\n      // - 'GraphQLEnumType:values:value' to change an individual value\n      GraphQLEnumType: [],\n      \"GraphQLEnumType:values\": [],\n      \"GraphQLEnumType:values:value\": [],\n    };\n  }\n\n  _setPluginName(name: ?string) {\n    this._currentPluginName = name;\n  }\n\n  /*\n   * Every hook `fn` takes three arguments:\n   * - obj - the object currently being inspected\n   * - build - the current build object (which contains a number of utilities and the context of the build)\n   * - context - information specific to the current invocation of the hook\n   *\n   * The function must either return a replacement object for `obj` or `obj` itself\n   */\n  hook<T: *>(hookName: string, fn: Hook<T, *, *>) {\n    if (!this.hooks[hookName]) {\n      throw new Error(`Sorry, '${hookName}' is not a supported hook`);\n    }\n    if (this._currentPluginName && !fn.displayName) {\n      fn.displayName = `${\n        this._currentPluginName\n      }/${hookName}/${fn.displayName || fn.name || \"anonymous\"}`;\n    }\n    this.hooks[hookName].push(fn);\n  }\n\n  applyHooks<T: *, Context>(\n    build: { ...Build },\n    hookName: string,\n    input: T,\n    context: Context,\n    debugStr: string = \"\"\n  ): T {\n    if (!input) {\n      throw new Error(\"applyHooks was called with falsy input\");\n    }\n    this.depth++;\n    try {\n      debug(`${INDENT.repeat(this.depth)}[${hookName}${debugStr}]: Running...`);\n\n      const hooks: Array<Hook<T, *, *>> = this.hooks[hookName];\n      if (!hooks) {\n        throw new Error(`Sorry, '${hookName}' is not a registered hook`);\n      }\n\n      let newObj = input;\n      for (const hook: Hook<T, *, *> of hooks) {\n        this.depth++;\n        try {\n          const hookDisplayName = hook.displayName || hook.name || \"anonymous\";\n          debug(\n            `${INDENT.repeat(\n              this.depth\n            )}[${hookName}${debugStr}]:   Executing '${hookDisplayName}'`\n          );\n\n          const previousHookName = build.status.currentHookName;\n          const previousHookEvent = build.status.currentHookEvent;\n          build.status.currentHookName = hookDisplayName;\n          build.status.currentHookEvent = hookName;\n          newObj = hook(newObj, build, context);\n          build.status.currentHookName = previousHookName;\n          build.status.currentHookEvent = previousHookEvent;\n\n          if (!newObj) {\n            throw new Error(\n              `Hook '${hook.displayName ||\n                hook.name ||\n                \"anonymous\"}' for '${hookName}' returned falsy value '${newObj}'`\n            );\n          }\n          debug(\n            `${INDENT.repeat(\n              this.depth\n            )}[${hookName}${debugStr}]:   '${hookDisplayName}' complete`\n          );\n        } finally {\n          this.depth--;\n        }\n      }\n\n      debug(`${INDENT.repeat(this.depth)}[${hookName}${debugStr}]: Complete`);\n\n      return newObj;\n    } finally {\n      this.depth--;\n    }\n  }\n\n  registerWatcher(listen: WatchUnwatch, unlisten: WatchUnwatch) {\n    if (!listen || !unlisten) {\n      throw new Error(\"You must provide both a listener and an unlistener\");\n    }\n    this.watchers.push(listen);\n    this.unwatchers.push(unlisten);\n  }\n\n  createBuild(): { ...Build } {\n    const initialBuild = makeNewBuild(this);\n    // Inflection needs to come first, in case 'build' hooks depend on it\n    initialBuild.inflection = this.applyHooks(\n      initialBuild,\n      \"inflection\",\n      initialBuild.inflection,\n      {\n        scope: {},\n      }\n    );\n    const build = this.applyHooks(initialBuild, \"build\", initialBuild, {\n      scope: {},\n    });\n    // Bind all functions so they can be dereferenced\n    bindAll(\n      build,\n      Object.keys(build).filter(key => typeof build[key] === \"function\")\n    );\n    Object.freeze(build);\n    this.applyHooks(build, \"init\", {}, { scope: {} });\n    return build;\n  }\n\n  buildSchema(): GraphQLSchema {\n    if (!this._generatedSchema) {\n      const build = this.createBuild();\n      this._generatedSchema = build.newWithHooks(\n        GraphQLSchema,\n        {},\n        {\n          __origin: `GraphQL built-in`,\n          isSchema: true,\n        }\n      );\n    }\n    if (!this._generatedSchema) {\n      throw new Error(\"Schema generation failed\");\n    }\n    return this._generatedSchema;\n  }\n\n  async watchSchema(listener?: SchemaListener) {\n    if (this._busy) {\n      throw new Error(\"An operation is in progress\");\n    }\n    if (this._watching) {\n      throw new Error(\n        \"We're already watching this schema! Use `builder.on('schema', callback)` instead.\"\n      );\n    }\n    try {\n      this._busy = true;\n      this._explicitSchemaListener = listener;\n      this.triggerChange = () => {\n        this._generatedSchema = null;\n        // XXX: optionally debounce\n        try {\n          const schema = this.buildSchema();\n          this.emit(\"schema\", schema);\n        } catch (e) {\n          // Build errors introduced while watching are ignored because it's\n          // primarily used in development.\n          // eslint-disable-next-line no-console\n          console.error(\n            \"⚠️⚠️⚠️ An error occured when building the schema on watch:\"\n          );\n          // eslint-disable-next-line no-console\n          console.error(e);\n        }\n      };\n      for (const fn of this.watchers) {\n        await fn(this.triggerChange);\n      }\n      if (listener) {\n        this.on(\"schema\", listener);\n      }\n      this.emit(\"schema\", this.buildSchema());\n      this._watching = true;\n    } finally {\n      this._busy = false;\n    }\n  }\n\n  async unwatchSchema() {\n    if (this._busy) {\n      throw new Error(\"An operation is in progress\");\n    }\n    if (!this._watching) {\n      throw new Error(\"We're not watching this schema!\");\n    }\n    this._busy = true;\n    try {\n      const listener = this._explicitSchemaListener;\n      this._explicitSchemaListener = null;\n      if (listener) {\n        this.removeListener(\"schema\", listener);\n      }\n      if (this.triggerChange) {\n        for (const fn of this.unwatchers) {\n          await fn(this.triggerChange);\n        }\n      }\n      this.triggerChange = null;\n      this._watching = false;\n    } finally {\n      this._busy = false;\n    }\n  }\n}\n\nexport default SchemaBuilder;\n"]}